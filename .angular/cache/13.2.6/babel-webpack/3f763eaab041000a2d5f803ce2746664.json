{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/Users/jrosenfeld/Documents/GitHub/figtest/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nrequire(\"/Users/jrosenfeld/Documents/GitHub/figtest/node_modules/core-js/modules/es.object.define-property.js\");\n\nrequire(\"/Users/jrosenfeld/Documents/GitHub/figtest/node_modules/core-js/modules/es.promise.js\");\n\nrequire(\"/Users/jrosenfeld/Documents/GitHub/figtest/node_modules/core-js/modules/es.object.to-string.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeImplementation = typeImplementation;\n\nvar _utils = require(\"../utils\");\n\nvar _click = require(\"../click\");\n\nvar _keyboard = require(\"../keyboard\");\n\nfunction typeImplementation(_x, _x2, _x3) {\n  return _typeImplementation.apply(this, arguments);\n}\n\nfunction _typeImplementation() {\n  _typeImplementation = _asyncToGenerator(function* (element, text, _ref) {\n    var delay = _ref.delay,\n        _ref$skipClick = _ref.skipClick,\n        skipClick = _ref$skipClick === void 0 ? false : _ref$skipClick,\n        _ref$skipAutoClose = _ref.skipAutoClose,\n        skipAutoClose = _ref$skipAutoClose === void 0 ? false : _ref$skipAutoClose,\n        _ref$initialSelection = _ref.initialSelectionStart,\n        initialSelectionStart = _ref$initialSelection === void 0 ? undefined : _ref$initialSelection,\n        _ref$initialSelection2 = _ref.initialSelectionEnd,\n        initialSelectionEnd = _ref$initialSelection2 === void 0 ? undefined : _ref$initialSelection2; // TODO: properly type guard\n    // we use this workaround for now to prevent changing behavior\n\n    if (element.disabled) return;\n    if (!skipClick) (0, _click.click)(element); // The focused element could change between each event, so get the currently active element each time\n\n    var currentElement = function () {\n      return (0, _utils.getActiveElement)(element.ownerDocument);\n    }; // by default, a new element has its selection start and end at 0\n    // but most of the time when people call \"type\", they expect it to type\n    // at the end of the current input value. So, if the selection start\n    // and end are both the default of 0, then we'll go ahead and change\n    // them to the length of the current value.\n    // the only time it would make sense to pass the initialSelectionStart or\n    // initialSelectionEnd is if you have an input with a value and want to\n    // explicitly start typing with the cursor at 0. Not super common.\n\n\n    var value = (0, _utils.getValue)(currentElement());\n\n    var _ref2 = (0, _utils.getSelectionRange)(element),\n        selectionStart = _ref2.selectionStart,\n        selectionEnd = _ref2.selectionEnd;\n\n    if (value != null && (selectionStart === null || selectionStart === 0) && (selectionEnd === null || selectionEnd === 0)) {\n      (0, _utils.setSelectionRange)(currentElement(), initialSelectionStart != null ? initialSelectionStart : value.length, initialSelectionEnd != null ? initialSelectionEnd : value.length);\n    }\n\n    var _ref3 = (0, _keyboard.keyboardImplementationWrapper)(text, {\n      delay: delay,\n      document: element.ownerDocument\n    }),\n        promise = _ref3.promise,\n        releaseAllKeys = _ref3.releaseAllKeys;\n\n    if (delay > 0) {\n      yield promise;\n    }\n\n    if (!skipAutoClose) {\n      releaseAllKeys();\n    } // eslint-disable-next-line consistent-return -- we need to return the internal Promise so that it is catchable if we don't await\n\n\n    return promise;\n  });\n  return _typeImplementation.apply(this, arguments);\n}","map":{"version":3,"sources":["/Users/jrosenfeld/Documents/GitHub/figtest/node_modules/@testing-library/user-event/dist/type/typeImplementation.js"],"names":["require","Object","defineProperty","exports","value","typeImplementation","_utils","_click","_keyboard","element","text","_ref","delay","_ref$skipClick","skipClick","_ref$skipAutoClose","skipAutoClose","_ref$initialSelection","initialSelectionStart","undefined","_ref$initialSelection2","initialSelectionEnd","disabled","click","currentElement","getActiveElement","ownerDocument","getValue","_ref2","getSelectionRange","selectionStart","selectionEnd","setSelectionRange","length","_ref3","keyboardImplementationWrapper","document","promise","releaseAllKeys"],"mappings":"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","sourcesContent":["\"use strict\";\n\nrequire(\"/Users/jrosenfeld/Documents/GitHub/figtest/node_modules/core-js/modules/es.object.define-property.js\");\n\nrequire(\"/Users/jrosenfeld/Documents/GitHub/figtest/node_modules/core-js/modules/es.promise.js\");\n\nrequire(\"/Users/jrosenfeld/Documents/GitHub/figtest/node_modules/core-js/modules/es.object.to-string.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeImplementation = typeImplementation;\n\nvar _utils = require(\"../utils\");\n\nvar _click = require(\"../click\");\n\nvar _keyboard = require(\"../keyboard\");\n\nasync function typeImplementation(element, text, _ref) {\n  var delay = _ref.delay,\n      _ref$skipClick = _ref.skipClick,\n      skipClick = _ref$skipClick === void 0 ? false : _ref$skipClick,\n      _ref$skipAutoClose = _ref.skipAutoClose,\n      skipAutoClose = _ref$skipAutoClose === void 0 ? false : _ref$skipAutoClose,\n      _ref$initialSelection = _ref.initialSelectionStart,\n      initialSelectionStart = _ref$initialSelection === void 0 ? undefined : _ref$initialSelection,\n      _ref$initialSelection2 = _ref.initialSelectionEnd,\n      initialSelectionEnd = _ref$initialSelection2 === void 0 ? undefined : _ref$initialSelection2;\n  // TODO: properly type guard\n  // we use this workaround for now to prevent changing behavior\n  if (element.disabled) return;\n  if (!skipClick) (0, _click.click)(element); // The focused element could change between each event, so get the currently active element each time\n\n  var currentElement = function () {\n    return (0, _utils.getActiveElement)(element.ownerDocument);\n  }; // by default, a new element has its selection start and end at 0\n  // but most of the time when people call \"type\", they expect it to type\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitly start typing with the cursor at 0. Not super common.\n\n\n  var value = (0, _utils.getValue)(currentElement());\n\n  var _ref2 = (0, _utils.getSelectionRange)(element),\n      selectionStart = _ref2.selectionStart,\n      selectionEnd = _ref2.selectionEnd;\n\n  if (value != null && (selectionStart === null || selectionStart === 0) && (selectionEnd === null || selectionEnd === 0)) {\n    (0, _utils.setSelectionRange)(currentElement(), initialSelectionStart != null ? initialSelectionStart : value.length, initialSelectionEnd != null ? initialSelectionEnd : value.length);\n  }\n\n  var _ref3 = (0, _keyboard.keyboardImplementationWrapper)(text, {\n    delay: delay,\n    document: element.ownerDocument\n  }),\n      promise = _ref3.promise,\n      releaseAllKeys = _ref3.releaseAllKeys;\n\n  if (delay > 0) {\n    await promise;\n  }\n\n  if (!skipAutoClose) {\n    releaseAllKeys();\n  } // eslint-disable-next-line consistent-return -- we need to return the internal Promise so that it is catchable if we don't await\n\n\n  return promise;\n}"]},"metadata":{},"sourceType":"script"}